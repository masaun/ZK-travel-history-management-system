{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":13576583408075163731,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof_a","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof_b","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"private"},{"name":"key_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/62OUQqAMAxD13Vzbnr/44oVM3x/IhgIvDalraVbI5zFFt7DjvrSITZwFnPWkRdwBc/Zjt4Q//HDgryB148/FPGWHs2brrzqXtP+rj2vOgFOiwfVfQEAAA==","debug_symbols":"nY9BCsMgEEXvMmsXUWMEr1JK0ESDIBrUFIp499pWSqBddfn+//NgCqxaHdtsvQkJxKWAC4vMNvhGBYZXlHbpn5SyjBnEOFEE2q8gGKcVgbFOg+Ckoq8pJnToW0yH8TOmvF4R4F/2CbN+wQn7395AReuc3ebzRy2+yWilcrqjOfxyavN9fzdN8QA=","file_map":{"37":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod schnorr;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod eddsa;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod ec;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(\n        crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y),\n    )\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"72":{"source":"use dep::std;\nmod tests; // tests/mod.nr\n\n/**\n * @notice - This function is used to verify the validity of the travel history.\n * @dev - A travel history should be a recursion proof. (See the details: https://noir-lang.org/docs/noir/standard_library/recursion )\n */\nfn main(\n    verification_key : [Field; 3], \n    proof_a : [Field; 3], \n    proof_b : [Field; 3], \n    public_inputs : [Field; 1], \n    key_hash : Field,\n) {\n    // Verify the travel proof \"a\"\n    std::verify_proof(\n        verification_key, \n        proof_a, \n        public_inputs, \n        key_hash\n    );\n\n    // Verify the travel proof \"b\"\n    std::verify_proof(\n        verification_key, \n        proof_b, \n        public_inputs, \n        key_hash\n    );\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// Reference Implementation of a \"Recursion Proof\": https://noir-lang.org/docs/noir/standard_library/recursion\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n// fn main(\n//     verification_key : [Field; 114],\n//     proof : [Field; 93],\n//     public_inputs : [Field; 1],\n//     key_hash : Field,\n//     proof_b : [Field; 93],\n// ) {\n//     std::verify_proof(\n//         verification_key,\n//         proof,\n//         public_inputs,\n//         key_hash\n//     );\n\n//     std::verify_proof(\n//         verification_key,\n//         proof_b,\n//         public_inputs,\n//         key_hash\n//     );\n// }","path":"/Users/unomasanori/Projects/DEMO_MVP/【Noir】【Electroneum Hackathon 2025】(Jan 8 ~ Mar 7, 2025)/zk-electroneum-in-noir/circuits/circuit-for-travel-history/src/main.nr"}},"names":["main"],"brillig_names":[]}